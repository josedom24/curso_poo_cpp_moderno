Perfecto. A continuación te presento el material didáctico formal para el siguiente apartado:

---

# 2.6 Métodos *getter* y *setter*: motivación, sintaxis y buenas prácticas

## Introducción

En diseño orientado a objetos, los atributos de una clase suelen declararse como `private` o `protected` para cumplir con el principio de **encapsulamiento**, impidiendo el acceso directo desde fuera de la clase.

Para permitir el acceso controlado a estos atributos, se emplean los métodos conocidos como:

* **Getters**: permiten **consultar** el valor de un atributo.
* **Setters**: permiten **modificar** el valor de un atributo, validando si es necesario.

---

## Motivación

### ¿Por qué no exponer los atributos como públicos?

Aunque sería más simple hacer los atributos públicos, esto **rompería el encapsulamiento**, exponiendo el estado interno del objeto sin ningún tipo de control ni validación. Por ejemplo:

```cpp
class Persona {
public:
    std::string nombre;
    int edad;
};
```

Cualquier parte del programa podría hacer:

```cpp
persona.edad = -99;  // Edad inválida
```

Esto es problemático porque **no hay garantía de integridad** del estado del objeto.

---

## Uso de getters y setters

Declarando los atributos como `private` y exponiendo funciones públicas de acceso y modificación, se protege el estado interno de la clase.

### Ejemplo

```cpp
class Persona {
private:
    std::string nombre;
    int edad;

public:
    // Getter
    std::string getNombre() const {
        return nombre;
    }

    int getEdad() const {
        return edad;
    }

    // Setter
    void setNombre(const std::string& nuevoNombre) {
        nombre = nuevoNombre;
    }

    void setEdad(int nuevaEdad) {
        if (nuevaEdad >= 0) {
            edad = nuevaEdad;
        }
    }
};
```

### Uso

```cpp
int main() {
    Persona p;
    p.setNombre("Lucía");
    p.setEdad(28);

    std::cout << p.getNombre() << " tiene " << p.getEdad() << " años.\n";
}
```

---

## Buenas prácticas

### 1. **Getters constantes**

Los *getters* deben marcarse como `const` si no modifican el estado del objeto.

```cpp
int getEdad() const;
```

### 2. **Pasar por referencia const para evitar copias costosas**

```cpp
const std::string& getNombre() const {
    return nombre;
}
```

Esto evita una copia innecesaria cuando el tipo es complejo.

### 3. **Validación en los setters**

Permite proteger la clase de estados inválidos.

```cpp
void setEdad(int nuevaEdad) {
    if (nuevaEdad >= 0) {
        edad = nuevaEdad;
    } else {
        std::cerr << "Edad inválida\n";
    }
}
```

### 4. **Evitar setters innecesarios**

No todo atributo necesita un setter. Si un atributo no debe cambiarse luego de inicializarse (por ejemplo, un identificador único), simplemente **no se proporciona el setter**.

---

## Representación UML

```plaintext
+---------------------------------------------+
|                  Persona                    |
+---------------------------------------------+
| - nombre: std::string                       |
| - edad: int                                 |
+---------------------------------------------+
| + getNombre(): const std::string&           |
| + getEdad(): int                            |
| + setNombre(nuevoNombre: const std::string&)|
| + setEdad(nuevaEdad: int)                   |
+---------------------------------------------+
```

---

## Alternativas modernas en C++

Aunque los *getters* y *setters* siguen siendo comunes, en algunos contextos modernos y controlados (por ejemplo, con `struct` en C++20), se pueden usar **atributos públicos inmutables** para objetos simples, especialmente en estructuras de datos o configuraciones.

Sin embargo, en clases con lógica compleja o responsabilidad significativa, el uso de métodos de acceso sigue siendo preferido por su capacidad de:

* Añadir validación,
* Registrar cambios (logs),
* Lanzar excepciones,
* Aplicar lógica de negocio.

---

## Conclusión

El uso de métodos *getter* y *setter* es una técnica clave para mantener el **encapsulamiento** y la **seguridad del estado interno** de los objetos. Permiten definir claramente cómo puede interactuar el mundo exterior con una clase, facilitando el mantenimiento y evolución del código sin romper contratos existentes.

En el siguiente apartado abordaremos cómo **sobrecargar operadores** para que los objetos se comporten de forma natural cuando se usen con operadores aritméticos o de comparación.

---

¿Deseas que continúe con el siguiente apartado: **Sobrecarga de operadores aritméticos y de comparación**?
