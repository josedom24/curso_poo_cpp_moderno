Por supuesto. A continuación te presento el material didáctico **reescrito y ampliado** para el apartado **"Constructores, destructores y métodos constantes"**, incluyendo el uso de `explicit`, `=default` y `=delete`.

---

# 2.4 Constructores, destructores y métodos constantes

## Introducción

En C++, la creación, uso y destrucción de objetos es controlada mediante **constructores**, **destructores** y **métodos constantes**. Estos mecanismos garantizan que los objetos se inicialicen correctamente, liberen recursos cuando ya no se necesiten y permitan el uso seguro de funciones que no alteran su estado.

En este apartado también se abordarán características modernas de C++ que proporcionan un mayor control sobre estas funciones especiales:

* El uso de `explicit` para evitar conversiones implícitas indeseadas.
* El uso de `=default` para solicitar al compilador una implementación por defecto.
* El uso de `=delete` para prohibir funciones específicas.

---

## Constructores

Un **constructor** es una función especial cuyo nombre coincide con el de la clase y que **no tiene tipo de retorno**. Se ejecuta automáticamente al crear un objeto y se utiliza para inicializar sus atributos.

### Tipos de constructores comunes

* **Constructor por defecto**: no recibe argumentos.
* **Constructor parametrizado**: recibe argumentos para inicializar atributos.
* **Constructor delegante**: llama a otro constructor de la misma clase (C++11).
* **Constructores especiales**: como el de copia y el de movimiento (se tratarán en otra sección).

---

### Ejemplo: Constructores básicos

```cpp
class Persona {
private:
    std::string nombre;
    int edad;

public:
    // Constructor por defecto
    Persona() : nombre("Desconocido"), edad(0) {}

    // Constructor parametrizado
    Persona(const std::string& n, int e) : nombre(n), edad(e) {}

    void presentarse() const {
        std::cout << "Soy " << nombre << " y tengo " << edad << " años.\n";
    }
};
```

---

## Constructores delegados (C++11)

Un **constructor delegante** permite que un constructor invoque a otro dentro de la misma clase. Esto mejora la coherencia de inicialización y evita duplicación de código.

### Ejemplo

```cpp
class Persona {
private:
    std::string nombre;
    int edad;

public:
    Persona(const std::string& n, int e) : nombre(n), edad(e) {}

    Persona() : Persona("Desconocido", 0) {}

    Persona(const std::string& n) : Persona(n, 0) {}

    void presentarse() const {
        std::cout << "Soy " << nombre << " y tengo " << edad << " años.\n";
    }
};
```

---

## El modificador `explicit`

Por defecto, C++ permite que un constructor con un solo parámetro sea usado para **conversiones implícitas**. Esto puede generar errores difíciles de detectar. Para evitarlos, se utiliza el modificador `explicit`.

### Ejemplo sin `explicit` (comportamiento implícito):

```cpp
class Entero {
public:
    Entero(int valor) { /* ... */ }
};

void imprimir(Entero e);

imprimir(5);  // Se permite: 5 se convierte implícitamente en Entero
```

### Ejemplo con `explicit`:

```cpp
class Entero {
public:
    explicit Entero(int valor) { /* ... */ }
};

imprimir(5);  // Error: conversión implícita prohibida
```

El uso de `explicit` hace el código más claro y seguro al evitar conversiones no deseadas.

---

## Destructor

El **destructor** es una función especial que se ejecuta automáticamente cuando un objeto se destruye. Su propósito principal es **liberar recursos** (memoria, archivos, conexiones, etc.).

### Sintaxis

```cpp
~NombreDeClase();
```

### Ejemplo

```cpp
class Persona {
public:
    Persona() {
        std::cout << "Creando persona\n";
    }

    ~Persona() {
        std::cout << "Destruyendo persona\n";
    }
};
```

---

## Métodos constantes

Un método puede declararse con el calificador `const` si **no modifica el estado del objeto**. Esto permite invocar el método sobre objetos constantes o referencias constantes.

### Ejemplo

```cpp
class Persona {
private:
    std::string nombre;
    int edad;

public:
    Persona(const std::string& n, int e) : nombre(n), edad(e) {}

    void presentarse() const {
        std::cout << "Soy " << nombre << " y tengo " << edad << " años.\n";
    }
};
```

### Beneficios

* Mejora la claridad del diseño.
* Aumenta la seguridad: garantiza que no se alterará el estado del objeto.
* Permite el uso en contextos donde solo se permite lectura.

---

## Uso de `=default` y `=delete` (C++11)

C++ permite controlar si ciertas funciones especiales (constructores, destructores, operadores, etc.) deben:

* Ser **generadas automáticamente** (`=default`).
* Ser **prohibidas explícitamente** (`=delete`).

### `=default`

Se utiliza para pedir al compilador que genere una implementación por defecto.

```cpp
class Persona {
public:
    Persona() = default;  // Usa el constructor por defecto generado por el compilador
    ~Persona() = default; // Destructor por defecto
};
```

### `=delete`

Se utiliza para **evitar** que una función especial pueda ser usada.

```cpp
class Persona {
public:
    Persona() = default;
    Persona(const Persona&) = delete;  // Se prohíbe la copia
};
```

Esto es útil para evitar que los objetos sean copiados, por ejemplo, si gestionan recursos únicos.

---

## Representación UML de la clase `Persona` completa

```plaintext
+--------------------------------------------+
|                 Persona                     |
+--------------------------------------------+
| - nombre: std::string                       |
| - edad: int                                 |
+--------------------------------------------+
| + Persona()                                 |
| + Persona(nombre: string)                   |
| + Persona(nombre: string, edad: int)        |
| + ~Persona()                                |
| + presentarse(): void const                 |
+--------------------------------------------+
```

---

## Conclusión

Los **constructores** permiten garantizar una inicialización válida, y los **constructores delegados** facilitan la reutilización del código de inicialización. El uso de `explicit` evita conversiones implícitas no deseadas, y los modificadores `=default` y `=delete` ofrecen un control fino sobre las funciones especiales de una clase.

El **destructor** asegura la correcta liberación de recursos, y los **métodos constantes** protegen la integridad del objeto, asegurando que algunas operaciones no alteren su estado.

Estas herramientas forman parte de la base de un diseño de clases robusto, seguro y expresivo en C++ moderno.

En el siguiente apartado profundizaremos en las **listas de inicialización**, un mecanismo eficiente y necesario para inicializar correctamente los atributos de una clase, especialmente cuando contienen referencias, constantes o tipos sin constructor por defecto.

---

¿Te gustaría que continúe con el siguiente apartado: **Inicialización de atributos con listas de inicialización**?
