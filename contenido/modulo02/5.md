Perfecto. A continuación te presento el material didáctico formal para el siguiente apartado del curso:

Aquí hay que estudiar los constructores delegados:

## Constructores delegados (C++11)

Un **constructor delegante** permite que un constructor invoque a otro dentro de la misma clase. Esto mejora la coherencia de inicialización y evita duplicación de código.

### Ejemplo

```cpp
class Persona {
private:
    std::string nombre;
    int edad;

public:
    Persona(const std::string& n, int e) : nombre(n), edad(e) {}

    Persona() : Persona("Desconocido", 0) {}

    Persona(const std::string& n) : Persona(n, 0) {}

    void presentarse() const {
        std::cout << "Soy " << nombre << " y tengo " << edad << " años.\n";
    }
};
```

---

---

# 2.5 Inicialización de atributos con listas de inicialización

## Introducción

En C++, los constructores permiten inicializar los atributos de una clase al momento de la creación del objeto. Una forma eficiente y preferida de hacerlo es mediante el uso de **listas de inicialización**.

La lista de inicialización ofrece varias ventajas sobre la asignación dentro del cuerpo del constructor, especialmente cuando se trabaja con **atributos constantes**, **referencias**, o **tipos sin constructor por defecto**. Además, es más eficiente y refleja mejor la intención de inicializar, no simplemente asignar.

---

## Sintaxis de la lista de inicialización

Una **lista de inicialización** aparece después de los paréntesis del constructor y antes del cuerpo, utilizando el carácter `:` seguido de una lista separada por comas:

```cpp
Clase::Clase(tipo1 arg1, tipo2 arg2)
    : atributo1(arg1), atributo2(arg2) {
    // cuerpo del constructor (opcional)
}
```

---

## Ejemplo básico

```cpp
class Persona {
private:
    std::string nombre;
    int edad;

public:
    Persona(const std::string& n, int e)
        : nombre(n), edad(e) {}

    void presentarse() const {
        std::cout << "Soy " << nombre << " y tengo " << edad << " años.\n";
    }
};
```

Este constructor inicializa los atributos `nombre` y `edad` directamente desde la lista de inicialización. No se produce una construcción por defecto seguida de una asignación, sino una **construcción directa** y eficiente.

---

## ¿Por qué usar listas de inicialización?

### 1. Para inicializar miembros `const`

Los miembros constantes deben **obligatoriamente** inicializarse en la lista de inicialización, ya que **no se pueden asignar** dentro del cuerpo del constructor.

```cpp
class Punto {
private:
    const double x;
    const double y;

public:
    Punto(double x_, double y_)
        : x(x_), y(y_) {}
};
```

### 2. Para inicializar referencias

Las referencias deben inicializarse en el momento de la construcción.

```cpp
class Referencia {
private:
    int& ref;

public:
    Referencia(int& r)
        : ref(r) {}
};
```

### 3. Para mejorar la eficiencia

Inicializar un atributo directamente es más eficiente que crearlo con un valor por defecto y luego reasignarlo.

```cpp
class Cadena {
private:
    std::string texto;

public:
    Cadena(const std::string& t)
        : texto(t) {} // mejor que texto = t;
};
```

### 4. Para inicializar tipos que **no tienen constructor por defecto**

```cpp
class NoCopiable {
public:
    NoCopiable(int) {}
    NoCopiable() = delete; // no hay constructor por defecto
};

class Contenedor {
private:
    NoCopiable obj;

public:
    Contenedor(int valor)
        : obj(valor) {}
};
```

---

## Comparación con asignación en el cuerpo del constructor

```cpp
class Persona {
private:
    std::string nombre;

public:
    // Forma incorrecta o menos eficiente
    Persona(const std::string& n) {
        nombre = n;  // primero se construye 'nombre' con su constructor por defecto y luego se asigna
    }

    // Forma correcta
    Persona(const std::string& n)
        : nombre(n) {}
};
```

---

## Orden de inicialización

**Importante**: Los atributos se inicializan **en el orden en que se declaran en la clase**, **no** en el orden que aparecen en la lista de inicialización. Desordenarlos puede generar advertencias o errores sutiles.

```cpp
class Ejemplo {
private:
    int a;
    int b;

public:
    Ejemplo(int x, int y)
        : b(y), a(x) {}  // Primero se inicializa a, luego b
};
```

---

## Uso combinado con delegación

Las listas de inicialización pueden combinarse con **constructores delegados** para maximizar la reutilización del código de inicialización.

```cpp
class Persona {
private:
    std::string nombre;
    int edad;

public:
    Persona()
        : Persona("Desconocido", 0) {}  // delegación

    Persona(const std::string& n)
        : Persona(n, 0) {}             // delegación

    Persona(const std::string& n, int e)
        : nombre(n), edad(e) {}        // inicialización directa
};
```

---

## Representación UML (actualizada)

```plaintext
+--------------------------------------------+
|                 Persona                     |
+--------------------------------------------+
| - nombre: std::string                       |
| - edad: int                                 |
+--------------------------------------------+
| + Persona()                                 |
| + Persona(nombre: string)                   |
| + Persona(nombre: string, edad: int)        |
| + presentarse(): void const                 |
+--------------------------------------------+
```

---

## Conclusión

El uso de **listas de inicialización** es una práctica esencial en el diseño de clases en C++ moderno. Aporta claridad, eficiencia y es **requerido** en casos como atributos `const`, referencias o tipos no copiables. Su uso correcto permite construir objetos de manera segura y eficaz, y es un componente clave del estilo de programación profesional en C++.

En el siguiente apartado analizaremos cómo implementar y utilizar **métodos getter y setter**, su motivación, buenas prácticas, y su papel en el diseño orientado a objetos.

---

¿Deseas que continúe con el apartado **"Métodos getter y setter: motivación, sintaxis y buenas prácticas"**?
