Perfecto. A continuación tienes el material didáctico formal para el apartado:

---

# 2.7 Sobrecarga de operadores aritméticos y de comparación

## Introducción

En C++, los **operadores** como `+`, `-`, `==`, `<`, entre otros, pueden **sobrecargarse** para que funcionen con objetos definidos por el programador. Esto permite que los objetos se comporten de manera intuitiva y natural cuando se combinan con estos operadores, como ocurre con los tipos integrados.

La sobrecarga de operadores es especialmente útil en clases que representan **valores numéricos, geométricos, temporales, cadenas, unidades físicas**, etc.

---

## ¿Qué es la sobrecarga de operadores?

La **sobrecarga de un operador** consiste en **definir una función con una sintaxis especial** que indica cómo debe comportarse el operador cuando se utiliza con objetos de una clase.

Por ejemplo, para que el operador `+` funcione con objetos de tipo `Punto2D`, se puede definir:

```cpp
Punto2D operator+(const Punto2D& a, const Punto2D& b);
```

---

## Sobrecarga como función miembro vs función libre

### Como **función miembro**

* Se usa cuando el operando izquierdo es el propio objeto (`this`).
* Se define dentro de la clase.

```cpp
class Punto {
public:
    int x, y;

    Punto(int x_, int y_) : x(x_), y(y_) {}

    Punto operator+(const Punto& otro) const {
        return Punto(x + otro.x, y + otro.y);
    }
};
```

### Como **función libre (fuera de la clase)**

* Se usa cuando se desea permitir simetría o cuando el operando izquierdo no es de la clase.
* Puede ser función amiga si necesita acceso a miembros privados.

```cpp
class Punto {
private:
    int x, y;

public:
    Punto(int x_, int y_) : x(x_), y(y_) {}

    int getX() const { return x; }
    int getY() const { return y; }

    friend Punto operator+(const Punto& a, const Punto& b);
};

Punto operator+(const Punto& a, const Punto& b) {
    return Punto(a.x + b.x, a.y + b.y);
}
```

---

## Ejemplo: clase `Fraccion`

```cpp
class Fraccion {
private:
    int numerador;
    int denominador;

public:
    Fraccion(int num, int den) : numerador(num), denominador(den) {}

    Fraccion operator+(const Fraccion& otra) const {
        int num = numerador * otra.denominador + otra.numerador * denominador;
        int den = denominador * otra.denominador;
        return Fraccion(num, den);
    }

    bool operator==(const Fraccion& otra) const {
        return numerador * otra.denominador == otra.numerador * denominador;
    }

    void imprimir() const {
        std::cout << numerador << "/" << denominador << "\n";
    }
};
```

### Uso

```cpp
int main() {
    Fraccion a(1, 2);
    Fraccion b(1, 3);
    Fraccion c = a + b;  // Usa operador +
    c.imprimir();        // 5/6

    if (a == b) {
        std::cout << "Son iguales\n";
    } else {
        std::cout << "Son diferentes\n";
    }
}
```

---

## Operadores comunes que pueden sobrecargarse

| Tipo                  | Operadores                              |
| --------------------- | --------------------------------------- |
| Aritméticos           | `+`, `-`, `*`, `/`, `%`                 |
| Comparación           | `==`, `!=`, `<`, `>`, `<=`, `>=`        |
| Asignación            | `=`, `+=`, `-=`, `*=`, `/=`, `%=`       |
| Incremento/decremento | `++`, `--`                              |
| Entrada/salida        | `<<`, `>>`                              |
| Subscripción          | `[]`                                    |
| Llamada a función     | `()`                                    |
| Conversión            | `operator Tipo` (explícita o implícita) |

> ⚠ No todos los operadores pueden sobrecargarse (por ejemplo, `.` o `::` no pueden).

---

## Buenas prácticas

* La sobrecarga debe **respetar la semántica esperada** del operador. Por ejemplo, `==` debe ser simétrico y consistente.
* Si se sobrecarga `==`, es recomendable también definir `!=`.
* Usar `const` para los parámetros y el propio método si no se modifica el estado.
* Para mayor legibilidad, considerar definir operadores complejos como funciones libres, especialmente si involucran simetría o tipos distintos.

---

## Representación UML del ejemplo `Fraccion`

```plaintext
+-----------------------------------+
|             Fraccion              |
+-----------------------------------+
| - numerador: int                  |
| - denominador: int                |
+-----------------------------------+
| + Fraccion(num: int, den: int)    |
| + operator+(otra: Fraccion): Fraccion |
| + operator==(otra: Fraccion): bool    |
| + imprimir(): void const          |
+-----------------------------------+
```

---

## Conclusión

La **sobrecarga de operadores** permite extender el lenguaje C++ de manera natural a los tipos definidos por el programador. Al hacerlo con cuidado y respetando la semántica de los operadores, se mejora la legibilidad, expresividad y usabilidad de las clases. Esta técnica es especialmente poderosa en bibliotecas matemáticas, gráficas, financieras o en cualquier dominio donde los objetos representan entidades que interactúan como valores.

En el siguiente apartado abordaremos los **atributos y métodos estáticos**, que pertenecen a la clase en sí y no a las instancias, y que permiten compartir información y comportamientos comunes a todos los objetos.

---

¿Deseas que continúe con el apartado **"Atributos y métodos estáticos"**?
