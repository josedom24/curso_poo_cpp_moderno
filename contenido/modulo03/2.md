Perfecto. A continuación, te presento el material didáctico para la sección:

---

# Asociaciones entre objetos y responsabilidades

## Introducción

En la programación orientada a objetos (POO), una **asociación** es una relación semántica entre dos o más clases, que indica que los objetos de una clase pueden interactuar o tener conocimiento de los objetos de otra clase. Estas asociaciones reflejan interacciones del mundo real y permiten distribuir adecuadamente las **responsabilidades** entre las distintas clases de un sistema.

Modelar correctamente las asociaciones es clave para lograr sistemas bien estructurados, cohesivos y con bajo acoplamiento.

---

## Tipos de asociaciones

Las asociaciones se pueden clasificar según su dirección, cardinalidad y duración.

### 1. Según dirección

* **Unidireccional**: Una clase conoce a otra, pero no al revés.
* **Bidireccional**: Ambas clases se conocen mutuamente.

### 2. Según cardinalidad

* **Uno a uno** (1:1): Un objeto está asociado con uno y solo un objeto de otra clase.
* **Uno a muchos** (1\:N): Un objeto está asociado con varios objetos de otra clase.
* **Muchos a muchos** (N\:M): Múltiples objetos de una clase están asociados con múltiples objetos de otra.

### 3. Según duración

* **Temporal**: La asociación se establece de forma momentánea (por ejemplo, durante una llamada a una función).
* **Permanente**: La asociación es parte del estado interno del objeto.

---

## Asociaciones vs Agregación/Composición

Las **asociaciones** son más generales que la **agregación** o la **composición**. Toda agregación o composición es una forma especializada de asociación, pero no toda asociación implica agregación o composición. En otras palabras:

> Una asociación **no implica necesariamente** propiedad o dependencia de ciclo de vida.

---

## Ejemplo de asociación simple

```cpp
#include <iostream>
#include <string>

class Cliente;

class Pedido {
public:
    Pedido(int numero, Cliente* cliente) 
        : numero_(numero), cliente_(cliente) {}

    void mostrar() const;

private:
    int numero_;
    Cliente* cliente_; // asociación con Cliente (unidireccional)
};

class Cliente {
public:
    Cliente(std::string nombre) : nombre_(nombre) {}

    std::string obtenerNombre() const { return nombre_; }

private:
    std::string nombre_;
};

void Pedido::mostrar() const {
    std::cout << "Pedido #" << numero_
              << " para cliente: " << cliente_->obtenerNombre() << '\n';
}
```

En este caso, la clase `Pedido` está asociada con la clase `Cliente`. El `Pedido` necesita conocer a su `Cliente` para poder mostrar sus datos, pero el `Cliente` no conoce a sus pedidos.

---

## Diseño orientado a responsabilidades

En POO, las **responsabilidades** de una clase son las tareas que debe realizar o la información que debe mantener. Al modelar asociaciones entre clases, es importante decidir:

* ¿Quién conoce a quién?
* ¿Quién debería encargarse de qué acción?
* ¿Qué objeto debería contener a qué otro (si aplica)?
* ¿Cómo asegurar que las clases no estén innecesariamente acopladas?

### Principios a tener en cuenta

* **Encapsulamiento**: Cada clase debe ocuparse únicamente de sus propias responsabilidades.
* **Bajo acoplamiento**: Las clases deben conocer lo mínimo necesario sobre otras clases.
* **Alta cohesión**: Una clase debe agrupar tareas estrechamente relacionadas.

---

## Ejemplo: distribución de responsabilidades

Supongamos que modelamos una `Biblioteca` que contiene varios `Libro` y permite a `Usuario` prestar libros.

```cpp
class Libro {
public:
    Libro(std::string titulo) : titulo_(titulo), prestado_(false) {}

    bool estaPrestado() const { return prestado_; }

    void prestar() { prestado_ = true; }

    std::string obtenerTitulo() const { return titulo_; }

private:
    std::string titulo_;
    bool prestado_;
};

class Usuario {
public:
    Usuario(std::string nombre) : nombre_(nombre) {}

    void prestarLibro(Libro& libro) {
        if (!libro.estaPrestado()) {
            libro.prestar();
            std::cout << nombre_ << " ha prestado el libro: " 
                      << libro.obtenerTitulo() << '\n';
        } else {
            std::cout << "El libro ya está prestado.\n";
        }
    }

private:
    std::string nombre_;
};
```

### Observaciones

* La clase `Usuario` no posee el `Libro`, pero está asociada a él mediante una operación.
* La lógica de préstamo está distribuida: `Libro` conoce su estado, `Usuario` ejecuta la acción.
* El acoplamiento entre `Usuario` y `Libro` es **mínimo**, limitado a la interacción necesaria.

---

## Conclusión

Las **asociaciones entre objetos** son fundamentales para modelar interacciones realistas en POO. Al definir una asociación, se deben analizar cuidadosamente las responsabilidades de cada clase y aplicar principios de diseño para lograr un sistema modular y flexible.

> Comprender la diferencia entre asociación, agregación y composición, y cómo se relacionan con las **responsabilidades**, es clave para un diseño orientado a objetos efectivo.

---

¿Deseas que continuemos con el siguiente tema: **Introducción a la herencia: clases base y derivadas**?
