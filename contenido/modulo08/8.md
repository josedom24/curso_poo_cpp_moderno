Con gusto. A continuación te presento el desarrollo didáctico del apartado **"Uso de `std::variant` y `std::visit` para patrones de diseño"**, con un enfoque formal y pedagógico, ideal para un curso de C++ moderno centrado en programación genérica y orientada a objetos:

---

## 8. Uso de `std::variant` y `std::visit` para Patrones de Diseño

### 8.1 Introducción

En el desarrollo de software, existen situaciones en las que una variable debe poder almacenar **uno de varios tipos posibles**, pero **solo uno a la vez**. Tradicionalmente, este problema se resolvía mediante uniones (`union`) en C o jerarquías de clases con polimorfismo dinámico en C++. Sin embargo, estas soluciones tienen limitaciones: la unión carece de seguridad de tipo y el polimorfismo implica sobrecarga en tiempo de ejecución.

C++17 introduce `std::variant`, una clase plantilla que representa una **alternativa segura en tiempo de compilación** a estos enfoques. Se trata de una forma moderna y robusta de implementar **tipos discriminados** o **sum types** (comunes en lenguajes funcionales), permitiendo escribir código más expresivo, seguro y eficiente.

---

### 8.2 ¿Qué es `std::variant`?

`std::variant<Ts...>` es una clase plantilla que puede contener un valor de uno (y solo uno) de los tipos especificados como parámetros. Internamente, es similar a una unión discriminada con un índice que indica qué tipo está activo.

```cpp
#include <variant>

std::variant<int, float> valor;
valor = 10;     // contiene un int
valor = 3.14f;  // ahora contiene un float
```

---

### 8.3 Inspección del Valor con `std::visit`

Para operar sobre el contenido de un `std::variant`, se utiliza `std::visit`, una función que aplica un **"visitor"** (objeto invocable) al valor activo de la variante.

```cpp
#include <iostream>
#include <variant>

std::variant<int, std::string> dato = "Hola";

std::visit([](auto&& valor) {
    std::cout << "Valor: " << valor << '\n';
}, dato);
```

La función lambda actúa como **visitante** genérico, operando sobre el valor activo, sin necesidad de realizar conversiones ni comprobaciones explícitas.

---

### 8.4 Ventajas frente a otras técnicas

| Técnica                  | Seguridad | Rendimiento | Mantenimiento | Legibilidad |
| ------------------------ | --------- | ----------- | ------------- | ----------- |
| `void*` / uniones        | Baja      | Alta        | Difícil       | Baja        |
| Jerarquías con `virtual` | Alta      | Media       | Moderada      | Media       |
| `std::variant`           | Alta      | Alta        | Clara         | Alta        |

---

### 8.5 Ejemplo Práctico: Procesamiento de Mensajes

Supongamos un sistema que puede recibir tres tipos distintos de mensajes:

```cpp
struct Texto { std::string contenido; };
struct Numero { int valor; };
struct Error { std::string motivo; };

using Mensaje = std::variant<Texto, Numero, Error>;

void procesar(const Mensaje& msg) {
    std::visit([](const auto& m) {
        if constexpr (std::is_same_v<decltype(m), Texto>)
            std::cout << "Mensaje de texto: " << m.contenido << '\n';
        else if constexpr (std::is_same_v<decltype(m), Numero>)
            std::cout << "Número recibido: " << m.valor << '\n';
        else if constexpr (std::is_same_v<decltype(m), Error>)
            std::cout << "Error: " << m.motivo << '\n';
    }, msg);
}
```

Uso:

```cpp
procesar(Texto{"Hola mundo"});
procesar(Numero{42});
procesar(Error{"Conexión fallida"});
```

---

### 8.6 Aplicación en Patrones de Diseño

El uso combinado de `std::variant` y `std::visit` permite implementar algunos **patrones de diseño clásicos** de manera más sencilla y segura:

#### 1. **Visitor Pattern** (visitante)

* Con `std::visit`, se evita la necesidad de jerarquías y sobrecarga de métodos virtuales.
* Se logra **doble despacho estático**, sin pérdida de rendimiento.

#### 2. **State Pattern** (estado)

* Representar distintos estados de un objeto como tipos distintos, almacenados en un `std::variant`.
* Cada estado puede definirse como una clase estructurada con su propia lógica.

#### 3. **Command Pattern** (comando)

* Cada comando puede modelarse como una estructura diferente.
* El `std::variant` permite encapsular múltiples comandos, y `std::visit` ejecuta el correspondiente.

---

### 8.7 Consideraciones y Buenas Prácticas

* ✅ Usar `std::variant` cuando se requiere **modelar múltiples alternativas excluyentes** con seguridad de tipo.
* ✅ Combinar con `std::visit` y `if constexpr` para **despacho estático** eficiente y legible.
* ⚠️ Evitar variantes excesivamente grandes (con muchos tipos), ya que complican el mantenimiento y pueden degradar la legibilidad.
* ⚠️ No usar `std::variant` como sustituto del polimorfismo cuando se requiere extensibilidad dinámica (ej. plugins).

---

### 8.8 Ejemplo Completo

```cpp
#include <iostream>
#include <variant>
#include <string>

struct Texto { std::string contenido; };
struct Numero { int valor; };
struct Error { std::string mensaje; };

using Mensaje = std::variant<Texto, Numero, Error>;

void mostrar(const Mensaje& msg) {
    std::visit([](const auto& m) {
        using T = std::decay_t<decltype(m)>;
        if constexpr (std::is_same_v<T, Texto>)
            std::cout << "Texto: " << m.contenido << '\n';
        else if constexpr (std::is_same_v<T, Numero>)
            std::cout << "Número: " << m.valor << '\n';
        else if constexpr (std::is_same_v<T, Error>)
            std::cout << "Error: " << m.mensaje << '\n';
    }, msg);
}

int main() {
    Mensaje m1 = Texto{"Hola mundo"};
    Mensaje m2 = Numero{2025};
    Mensaje m3 = Error{"Archivo no encontrado"};

    mostrar(m1);
    mostrar(m2);
    mostrar(m3);

    return 0;
}
```

---

### 8.9 Conclusión

El uso de `std::variant` y `std::visit` representa un enfoque moderno y seguro para gestionar **tipos heterogéneos y alternativas excluyentes**. Estas herramientas amplían las posibilidades del lenguaje, ofreciendo alternativas al polimorfismo clásico con ventajas en rendimiento, claridad y seguridad. Su dominio permite aplicar patrones de diseño de forma más funcional y eficaz en el contexto de C++ moderno.

---

¿Te gustaría que este apartado incluyera ejercicios para diseñar un sistema de comandos con `std::variant`, o ejemplos de refactorización de jerarquías clásicas usando variantes?
