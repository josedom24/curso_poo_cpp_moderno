Con gusto. A continuación, te presento el desarrollo didáctico del apartado **"Plantilla de clase: `std::optional`"**, redactado con lenguaje formal y pedagógico, adecuado para un curso de C++ moderno orientado a la programación genérica y orientada a objetos:

---

## 7. Plantilla de Clase: `std::optional`

### 7.1 Introducción

En la programación tradicional en C++, el uso de punteros nulos (`nullptr`) ha sido una técnica común para representar la **ausencia de valor**. Sin embargo, este enfoque tiene múltiples limitaciones: falta de seguridad de tipo, posibilidad de errores en tiempo de ejecución (como desreferenciar punteros nulos), y escasa expresividad semántica.

Para abordar estos problemas, C++17 introdujo la clase plantilla `std::optional`, una herramienta que permite **representar explícitamente un valor que puede estar presente o ausente** de forma segura y expresiva. Se trata de una solución moderna, fuertemente tipada y alineada con prácticas de diseño robusto.

---

### 7.2 Concepto

`std::optional<T>` es una plantilla de clase que encapsula un valor de tipo `T`, o la ausencia de dicho valor. Permite evitar el uso de punteros o valores especiales (como `-1` o `""`) para indicar condiciones especiales, y mejora la claridad del código.

### 7.3 Inclusión de Cabecera

Para utilizar `std::optional`, es necesario incluir el encabezado:

```cpp
#include <optional>
```

---

### 7.4 Sintaxis Básica

```cpp
#include <optional>

std::optional<int> obtenerNumero(bool exito) {
    if (exito) {
        return 42;
    } else {
        return std::nullopt;
    }
}
```

Aquí, `std::nullopt` representa la ausencia de valor. La función puede retornar un número válido o ninguno, sin necesidad de punteros ni valores centinela.

---

### 7.5 Operaciones Comunes

#### 1. **Comprobar si contiene un valor**

```cpp
if (resultado.has_value()) {
    std::cout << "Valor: " << resultado.value() << "\n";
}
```

#### 2. **Obtener el valor con valor por defecto**

```cpp
int valor = resultado.value_or(0);  // Si no hay valor, devuelve 0
```

#### 3. **Asignar y modificar**

```cpp
std::optional<std::string> nombre;
nombre = "Carlos";
```

---

### 7.6 Ejemplo Práctico

```cpp
#include <iostream>
#include <optional>
#include <string>

std::optional<std::string> buscarUsuarioPorId(int id) {
    if (id == 1) return "Admin";
    return std::nullopt;
}

int main() {
    auto usuario = buscarUsuarioPorId(1);

    if (usuario) {
        std::cout << "Usuario encontrado: " << *usuario << '\n';
    } else {
        std::cout << "Usuario no encontrado\n";
    }

    return 0;
}
```

---

### 7.7 Ventajas de `std::optional`

* ✅ Mejora la **expresividad del código** al declarar explícitamente cuándo un valor puede no estar presente.
* ✅ Elimina la necesidad de usar **punteros nulos** o valores mágicos.
* ✅ Proporciona **seguridad de tipo** en tiempo de compilación.
* ✅ Compatible con operaciones funcionales como encadenamiento y composición (a partir de C++23 con `and_then`, `transform`, etc.).

---

### 7.8 Consideraciones y Buenas Prácticas

* ⚠️ El método `value()` lanza una excepción (`std::bad_optional_access`) si se accede al valor sin comprobar su presencia.
* ⚠️ `std::optional<T>` debe usarse principalmente con tipos **ligeros o triviales**. Para tipos grandes o costosos de copiar, puede implicar sobrecarga.
* ✅ Ideal para funciones que **pueden fallar pero no requieren detalles del error** (caso contrario, considerar `std::expected` en C++23 o variantes propias).

---

### 7.9 Comparación con Punteros y Valores Centinela

| Enfoque               | Seguridad | Claridad | Riesgo de errores |
| --------------------- | --------- | -------- | ----------------- |
| Puntero (`T*`)        | Baja      | Media    | Alta              |
| Valor especial (`-1`) | Muy baja  | Baja     | Muy alta          |
| `std::optional<T>`    | Alta      | Alta     | Baja              |

---

### 7.10 Conclusión

`std::optional` representa una mejora significativa en la gestión de valores opcionales en C++. Gracias a su integración en el lenguaje y su compatibilidad con el sistema de tipos, permite escribir código más claro, expresivo y seguro. Es una herramienta esencial en el arsenal del programador moderno, especialmente útil en interfaces públicas, validaciones condicionales y operaciones que pueden fallar de forma esperada.

---

¿Te gustaría que este apartado incluyera actividades prácticas, como rediseñar funciones tradicionales usando `std::optional`, o un ejercicio comparativo con punteros nulos?
